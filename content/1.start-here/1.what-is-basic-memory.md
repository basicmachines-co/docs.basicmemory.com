---
title: What is Basic Memory
description: An overview of what Basic Memory is and how it works.
---

Basic Memory is a knowledge base that you and your AI assistant share. It stores notes as Markdown files so your work stays readable, portable, and searchable.

Instead of losing valuable insights in conversation history, you build a persistent knowledge base where both you and AI can read, write, and enhance each other's work.

---
:video{autoplay controls loop muted src="https://basicmemory.com/videos/explainer-video.mp4"}

## Why Basic Memory?

**The problem:** AI conversations are ephemeral. You have a great discussion, make important decisions, learn something new - and then it's gone, buried in chat history.

**The solution:** Basic Memory gives your AI assistant a persistent memory. Knowledge captured in one conversation is available in all future conversations. Your AI can reference past discussions, decisions, and context.

**Key benefits:**
- **Persistent context** - Knowledge survives across conversations
- **You own your data** - Plain Markdown files you control
- **Structured knowledge** - Observations and relations create a semantic graph
- **Works with any AI** - Claude, ChatGPT, and other MCP-compatible assistants

---

## What it does

:::card-group
::card
---
title: Stores notes as Markdown
icon: i-lucide-file-text
---
Notes are plain files you can edit with any editor. No lock-in, no proprietary formats.
::

::card
---
title: Connects ideas with links
icon: i-lucide-link
---
Relations and tags turn notes into a knowledge graph that grows over time.
::

::card
---
title: Lets assistants search and write
icon: i-lucide-search
---
MCP tools let your assistant read, write, search, and organize notes.
::

::card
---
title: Cloud or Local
icon: i-lucide-cloud
---
Use the hosted cloud service or run everything locally - your choice.
::
:::

---

## How it works

Basic Memory runs an MCP server that can read and write Markdown files. A SQLite index keeps search fast. Your assistant calls tools like `search_notes`, `read_note`, and `write_note` to work with your notes.

::mermaid
---
code: |
  flowchart LR
      subgraph You
          A[AI Assistant]
          E[Editor]
      end

      subgraph Basic Memory
          M[MCP Server]
          I[Index]
      end

      subgraph Storage
          F[Markdown Files]
      end

      A <-->|MCP Tools| M
      E <-->|Edit| F
      M <-->|Read/Write| F
      M <-->|Query| I
      F -.->|Sync| I
---
::

### The workflow

1. **Capture a note** - You write or ask your assistant to write a note during a conversation.

2. **Index and connect** - The system indexes the note, extracts observations and relations, and links it to related notes.

3. **Reuse later** - In future conversations, your assistant searches and loads relevant context automatically.

### Example conversation

```bash
You: "What did we decide about the authentication approach?"

AI: [Searches knowledge base, finds your past notes]
        "Based on your notes, you decided to use JWT tokens for API
        authentication. The decision was made on January 15th and
        documented in 'Decision: API Authentication'."

You: "Add a note about implementing refresh tokens"

AI: [Creates a new note linked to the authentication decision]
        "I've created a note about refresh tokens and linked it to
        your authentication decision notes."
```

---

## What a note looks like

Notes are standard Markdown with optional semantic structure:

```bash
---
title: API Authentication Decision
tags: [security, api, auth]
---

# API Authentication Decision

## Context
We needed to choose an authentication approach for the new API.

## Observations
- [decision] Use JWT tokens for API auth #security
- [requirement] Tokens expire after 24 hours
- [risk] Rate limiting needed on login endpoint #auth

## Relations
- implements [[API Security Spec]]
- depends_on [[User Service]]
- relates_to [[Token Refresh]]
```

**Key concepts:**
- **Observations** - Categorized facts: `[decision]`, `[requirement]`, `[risk]`, etc.
- **Relations** - Links to other notes: `[[Other Note]]` in simple WiliLink format
- **Tags** - Searchable metadata: `#security`, `#api`

::tip 
The headings '## Observations' and '## Relations' are only informative. Basic Memory will parse elements from any
where in the Markdown. 
::

---

## What the AI sees

When your AI assistant searches your knowledge base, it doesn't just find text - it navigates a semantic graph of connected ideas.

### The knowledge graph

Each note becomes an **entity** with structured data:

::mermaid
---
code: |
  flowchart TD
      subgraph "Knowledge Graph"
          E1[API Authentication]
          E2[API Security Spec]
          E3[User Service]
          E4[Token Refresh]
      end

      subgraph "API Authentication: Facts"
          O1[JWT]
          O2[Tokens exgire]
          O3[Rate limiting]
      end

      E1 -->|implements| E2
      E1 -->|depends_on| E3
      E1 -->|relates_to| E4

      E1 -->|decision| O1
      E1 -->|requirement| O2
      E1 -->|risk| O3
---
::

- **Entities** - Each note is an entity with a title, content, and metadata
- **Observations** - Categorized facts extracted from the note (decisions, requirements, risks)
- **Relations** - Typed links connecting entities (`implements`, `depends_on`, `relates_to`)

### Building context

When you ask a question, the AI doesn't just return one note. It traverses the graph to build rich context:

::mermaid
---
code: |
  flowchart LR
      Q[Your Question] --> S[search_notes]
      S --> R[Matching Notes]

      R --> G[Relationed Notes]
      R -->|Build| C[Context]
      C --> A[AI Response]
      G -->|Follow| R
---
::

**The flow:**

1. **Search** - Your question triggers a search across all notes
2. **Expand** - The AI uses `build_context` to follow relations and gather connected notes
3. **Synthesize** - With the full context loaded, the AI can give a complete answer

This recursive traversal means asking about "API authentication" automatically pulls in related decisions, dependencies, and connected topics - giving your AI the full picture.

### Memory URLs

The AI references knowledge using `memory://` URLs:

```bash
memory://api-authentication          # Reference by permalink
memory://api-authentication/relates_to/*  # Follow all 'relates_to' links
memory://folder/note-title           # Reference by path
```

These stable identifiers let the AI (and you) pinpoint exactly what context to load.

::tip
You don't have to understand or think about the object graph or relations. You can just ask the AI to manage it for you.
::

```bash
You: "Make sure you add observations and relations to this note"

AI: [Update the note with semantic information]
    "OK I've updated the note with observations and relations...."

You: "Make sure you do this for all our other notes :)"

AI: [Makes a note in its own memory to keep notes annotated with semantic information]
    "I'll remember that...."
```

---

## Seeing into the black box

AI memory is typically opaque - you don't know what context the AI has or what it "remembers." Basic Memory makes this transparent.

- **See what your AI sees** - Every piece of context is a file you can read
- **Edit what your AI knows** - Modify, delete, or reorganize knowledge anytime
- **Watch changes happen** - See exactly what your AI adds or updates
- **Keep your memory** - Plain Markdown files you own forever
- **Audit trail** - Every note has a history; you can see what was added when
- **No surprises** - The AI can only know what's in your files; no hidden context
- **Portable knowledge** - Plain markdown means you're never locked in; chat with one AI, bring your knowledge to the next

---

## Closing the loop

AI agents work best when they can observe the results of their actions. Basic Memory creates a feedback loop where each conversation builds on the last.

**How it works:**
- **Cumulative intelligence** - Each conversation adds to the knowledge base, making future conversations smarter
- **Human-in-the-loop refinement** - You can correct and improve AI-generated notes, and the AI learns from your edits
- **Context compounds** - Unlike chat history that gets truncated, knowledge persists and connects
- **Pattern recognition** - Over time, the AI can recognize patterns across your entire knowledge base

### The feedback loop

::mermaid
---
code: |
  flowchart LR
      A[Conversation] --> B[AI Writes Memory]
      B --> C[Human Reviews/Edits]
      C --> D[AI Reads Context]
      D --> A
---
::

Each cycle reinforces learning. You ask questions, the AI searches and responds, creates notes from the conversation, and you review and refine. The knowledge base grows with each iteration.

### Knowledge growth over time

::mermaid
---
code: |
  flowchart TD
      subgraph "The Loop"
          A[Ask Question] --> B[AI Searches Memory]
          B --> C[AI Responds + Writes]
          C --> D[You Review & Refine]
          D --> E[Knowledge Base Grows]
          E --> B
      end
---
::


### Knowledge refinement over time

Each conversation builds on previous context, creating increasingly refined understanding:

::mermaid
---
code: |
  flowchart TD
      A[Conversation 1] --> B[Memory v1]
      B --> C[Conversation 2]
      C --> D[Memory v2 - refined]
      D --> E[Conversation 3]
      E --> F[Memory v3 - richer]
      F --> G[...]
---
::

The result: your AI gets smarter about *your* work with every interaction.

---

## Where it runs

### Cloud

Basic Memory Cloud provides:
- **Hosted MCP endpoint** - Connect without installing anything
- **Access from any device** - Use your memory from desktop, mobile, cli, multiple AIs
- **Web app** - Browse and edit notes in your browser
- **Local sync** - Sync your notes locally for easy management
- **Snapshots** - Point-in-time backups, automaticly done daily or manual as needed

### Local

The open-source local version provides:
- **Full control** - Everything runs on your machine
- **No account needed** - Use immediately after install
- **CLI tools** - Command-line access to all features
- **Offline access** - Works without internet

**Both use the same Markdown format**, so you can start with one and switch to the other later.

---

## MCP Integration

Basic Memory uses the [Model Context Protocol (MCP)](https://modelcontextprotocol.io/) to connect with AI assistants. MCP is an open standard that lets AI assistants use external tools.

**Available tools:**
- `write_note` - Create or update notes
- `read_note` - Read notes with context
- `search_notes` - Full-text search
- `edit_note` - Incremental editing
- `build_context` - Load related notes
- `list_memory_projects` - Manage projects
- ...and many more

**Compatible assistants:**
- Claude Desktop
- Claude Code
- ChatGPT (Pro/Max)
- Google Gemini
- Cursor
- VS Code (with MCP extension)
- Codex

---

## Getting started

Ready to try Basic Memory?

:::card-group
::card
---
title: "Quickstart: Cloud"
icon: i-lucide-cloud
to: /start-here/quickstart-cloud
---
Connect in 2 minutes. No installation required.
::

::card
---
title: "Quickstart: Local"
icon: i-lucide-hard-drive
to: /start-here/quickstart-local
---
Install locally and run everything on your machine.
::
:::

---

## Next steps

:::card-group
::card
---
title: Getting Started
icon: i-lucide-rocket
to: /start-here/getting-started
---
Full installation guide with configuration options.
::

::card
---
title: Knowledge Format
icon: i-lucide-file-text
to: /concepts/knowledge-format
---
Learn the note structure with observations and relations.
::

::card
---
title: MCP Tools Reference
icon: i-lucide-wrench
to: /reference/mcp-tools-reference
---
All available tools for AI assistants.
::
:::

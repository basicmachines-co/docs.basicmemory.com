---
title: Schema System
description: Define, validate, and evolve note structure in Basic Memory with schemas.
---

A schema is a description of what a "good" note of a particular type should contain. You already write notes with observations and relations — schemas just formalize those patterns so Basic Memory can check your notes against them.

Schemas are optional. You can use Basic Memory without ever defining a schema. But as your knowledge base grows, schemas help you maintain consistency and give AI assistants a guide for creating well-structured notes.

---

## Why schemas?

Knowledge bases grow organically. After writing 200 `person` notes over several months, you might notice inconsistency: some notes have a `[name]` observation, some use `[full_name]`. Some use a `works_at` relation, others say `employed_by`. The information is all there, but the lack of consistency makes it harder to search, filter, and build on.

Schemas give you a way to define what "consistent" means for a note type, and then check your notes against that definition. The key insight is that schemas are *descriptive*, not *prescriptive* — they describe your existing note patterns rather than forcing a rigid template upfront. You can start writing notes however feels natural, then add schemas later to bring order to what you've already created.

---

## What schemas check

Schemas validate against the note format you already use:

- **Observations** (`- [category] value`) — A schema can require or suggest specific observation categories. If your `person` schema says `name: string`, then Basic Memory expects to find a `- [name] ...` observation.
- **Relations** (`- relation_type [[Target]]`) — A schema can define expected relations. If `works_at` is defined as an `Organization` type, Basic Memory expects a `- works_at [[...]]` relation.
- **Frontmatter fields** — Schemas can check for specific frontmatter values like `tags` or custom metadata.

Schemas are just regular notes with `type: schema` in the frontmatter. There's nothing special about them — they live in your knowledge base alongside everything else.

---

## Picoschema syntax

Schemas use [Picoschema](https://google.github.io/dotprompt/reference/picoschema/) — a compact YAML-based syntax for defining fields. Each line declares a field name, its type, and an optional description.

### Types

| Type | Meaning | Example |
|------|---------|---------|
| `string` | Free-text value | `name: string` |
| `integer` | Whole number | `priority: integer` |
| `number` | Any numeric value | `score: number` |
| `boolean` | True/false | `active: boolean` |
| `any` | Any value accepted | `notes: any` |
| `CapitalizedName` | Reference to another entity | `works_at: Organization` |

When a type name is capitalized (like `Organization`), it signals an entity reference — Basic Memory expects a wiki-link relation rather than a plain observation.

### Modifiers

| Syntax | Meaning | Example |
|--------|---------|---------|
| `field: type` | Required field | `name: string` |
| `field?: type` | Optional field | `role?: string` |
| `field(array): type` | Required array (multiple values) | `skills(array): string` |
| `field?(array): type` | Optional array | `expertise?(array): string` |
| `field?(enum): [values]` | Value must be one of listed options | `status?(enum): [active, inactive, alumni]` |
| `field?(object):` | Nested object (indented fields below) | See example below |

### Descriptions

Add a description after a comma to document what the field means:

```yaml
name: string, full legal name
role?: string, current job title or position
works_at?: Organization, primary employer
```

### Complete annotated example

```yaml
schema:
  name: string, full legal name
  role?: string, current job title
  email?: string, primary contact email
  works_at?: Organization, primary employer
  expertise?(array): string, areas of knowledge
  status?(enum): [active, inactive, alumni], current relationship status
  contact_info?(object):
    phone?: string
    location?: string
```

This schema says: every note of this type *must* have a `name` observation. It *should* have a `role`, `email`, `works_at` relation, and so on — but those are optional. The `expertise` field expects multiple observations (an array). The `status` field constrains values to one of three choices.

---

## Defining schemas

There are three ways to attach a schema to a note.

### 1. Dedicated schema note (recommended)

Create a markdown file with `type: schema` in its frontmatter. This is the best approach for note types you use repeatedly — `person`, `meeting`, `decision`, `project`, and so on.

```yaml
---
title: Person
type: schema
entity: person
version: 1
schema:
  name: string, full name
  role?: string, job title
  email?: string, contact email
  works_at?: Organization, employer
  expertise?(array): string, areas of knowledge
settings:
  validation: warn
---

# Person

Schema for people in the knowledge base. Every person note should have a name
and optionally include their role, contact info, and employer.

Use `type: person` in your note frontmatter to match this schema.
```

The note body is regular markdown — use it to describe the schema's purpose, provide examples, or document conventions for your team. Basic Memory reads the schema definition from the frontmatter; the body is for humans.

**Frontmatter fields for schema notes:**

| Field | Required | Description |
|-------|----------|-------------|
| `type` | Yes | Must be `schema` |
| `entity` | Yes | The note type this schema applies to (e.g., `person`) |
| `version` | No | Schema version number for tracking changes |
| `schema` | Yes | The field definitions in picoschema syntax |
| `settings` | No | Configuration like `validation: warn` |

Place schema notes in a `schemas/` folder by convention (e.g., `schemas/person.md`), though any location works.

### 2. Inline schema in a single note

Useful for one-off structure or prototyping before committing to a reusable schema:

```yaml
---
title: Team Standup 2026-02-10
type: meeting
schema:
  attendees(array): string, participants
  decisions?(array): string, outcomes
  blockers?(array): string, unresolved issues
  action_items?(array): string, follow-up tasks
---
```

The schema applies only to this specific note. If you find yourself copying the same inline schema into multiple notes, promote it to a dedicated schema note.

### 3. Explicit schema reference

Point a note to a schema by name or path:

```yaml
---
title: Ada Lovelace
type: person
schema: Person
---
```

Or by path:

```yaml
---
title: Ada Lovelace
type: person
schema: schemas/person
---
```

This is useful when the note's `type` doesn't match the schema's `entity` field, or when you want to be explicit about which schema to use.

---

## Schema resolution

When you validate a note, Basic Memory needs to find the right schema. It checks in this order:

1. **Inline schema** — If the note has a `schema` dict in its frontmatter, use that directly.
2. **Explicit reference** — If the note has a `schema` string in its frontmatter (like `schema: Person`), look up that schema note by title or path.
3. **Implicit by type** — Look for a schema note whose `entity` field matches the note's `type`. For example, a note with `type: person` automatically matches a schema note with `entity: person`.
4. **No schema** — If none of the above match, no validation is performed. This is fine — not every note needs a schema.

This resolution order means you can start simple (implicit matching by type) and add explicit references only when you need more control.

---

## How fields map to notes

Each field in a schema corresponds to something Basic Memory expects to find in the note:

| Schema declaration | What it expects in the note | Example in note |
|---|---|---|
| `name: string` | Required observation | `- [name] Ada Lovelace` |
| `role?: string` | Optional observation | `- [role] Mathematician` |
| `expertise?(array): string` | Multiple observations with same category | `- [expertise] Mathematics`<br>`- [expertise] Computing` |
| `works_at?: Organization` | Optional relation (wiki-link) | `- works_at [[Analytical Engine Project]]` |
| `status?(enum): [active, inactive]` | Observation with constrained value | `- [status] active` |

The mapping is natural: string fields become observations, capitalized entity types become relations, and arrays expect multiple entries. Schemas describe your existing note patterns — they don't introduce a new authoring format.

---

## Validation modes

Control how strictly Basic Memory enforces schemas with the `validation` setting:

| Mode | Behavior | When to use |
|------|----------|-------------|
| `off` | No validation performed | Temporarily disable checks while restructuring |
| `warn` | Reports issues but doesn't block anything | Default for active writing and gradual adoption |
| `strict` | Treats issues as errors | Enforced workflows, CI checks, mature schemas |

Start with `warn`. This lets you see what's missing without disrupting your workflow. Move to `strict` only after your note patterns have stabilized and you're confident in the schema.

---

## The schema lifecycle

Schemas don't stop notes from being written. You can always create and edit notes freely, with or without a schema. Schemas give the AI an extra capability — the ability to check its own work and follow your preferred patterns. Think of them as guidelines, not gatekeepers.

The lifecycle is iterative: discover patterns, formalize them, validate, and evolve over time.

### Working with schemas through conversation

The most natural way to use schemas is through conversation with your AI assistant.

**Discovering patterns:**

```
You: "I've been writing a lot of person notes. Can you figure out
      what structure they have in common?"

Claude: [Uses schema_infer to analyze your person notes]

Looking at your 45 person notes, here's what I found:
- "name" appears in 95% of notes
- "role" appears in 80%
- "works_at" relation appears in 60%
- "expertise" appears in 40%

Want me to create a schema note based on these patterns?
```

**Creating a schema:**

```
You: "Yes, make name required and the rest optional."

Claude: [Creates schemas/person.md with type: schema]

Done! I've created a Person schema. Notes with type: person
will be checked against it.
```

**Validating notes:**

```
You: "How do my existing person notes look against that schema?"

Claude: [Uses schema_validate with entity_type="person"]

42 of 45 notes pass validation. Three are missing the [name]
observation:
- people/mystery-contact.md
- people/quick-note-jane.md
- people/old-import-2024.md

Want me to fix those?
```

**Checking drift later:**

```
You: "It's been a few months — are my person notes still consistent?"

Claude: [Uses schema_diff with entity_type="person"]

Most notes still follow the schema. I notice "linkedin" observations
are showing up in 35% of newer notes but aren't in the schema.
Want me to add it as an optional field?
```

**Writing notes with schema guidance:**

When a schema exists, the AI uses it as a creation guide automatically. It includes all required fields and relevant optional ones without you having to ask:

```python
# AI looks up the schema for "person" notes
schema = await schema_infer(entity_type="person")

# AI creates a note following the schema
await write_note(
    title="Grace Hopper",
    content="""# Grace Hopper

## Observations
- [name] Grace Hopper
- [role] Computer Scientist and Navy Admiral
- [expertise] Compiler design
- [expertise] Programming languages

## Relations
- works_at [[US Navy]]
- works_at [[Harvard University]]
""",
    directory="people",
    note_type="person",
    project="main"
)

# AI validates the result
await schema_validate(identifier="people/grace-hopper")
```

Your schemas do double duty: they help you maintain consistency *and* they guide AI assistants toward producing notes that match your preferred format. The AI doesn't need special instructions for each note type — the schema provides the structure automatically.

### Working with schemas from the CLI

You can do the same lifecycle from the command line:

```bash
# 1. Analyze your existing notes to discover patterns
bm schema infer person

# 2. Save the inferred schema as a note
bm schema infer person --save

# 3. Validate a single note
bm schema validate people/ada-lovelace.md

# 4. Validate all notes of a type
bm schema validate person

# 5. Check for drift over time
bm schema diff person
```

---

## MCP tool parameters

### `schema_validate`

Validate notes against their schema. Pass either an `entity_type` to validate all notes of that type, or an `identifier` to validate a specific note.

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `entity_type` | string | One of these | Note type to validate (e.g., `person`) — validates all notes of this type |
| `identifier` | string | required | Specific note to validate (path or permalink) |
| `project` | string | No | Project to validate in |

### `schema_infer`

Analyze existing notes of a type and suggest a schema based on common patterns.

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `entity_type` | string | Yes | Note type to analyze (e.g., `person`) |
| `threshold` | float | No | Minimum frequency for field inclusion (default `0.25` — fields in 25%+ of notes) |
| `project` | string | No | Project to analyze |

### `schema_diff`

Compare a schema definition against actual note usage to detect drift.

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `entity_type` | string | Yes | Note type to compare (e.g., `person`) |
| `project` | string | No | Project to compare in |

---

## CLI reference

### `bm schema validate`

Validate notes against a schema.

```bash
# Validate all notes of a type
bm schema validate person

# Validate a specific note
bm schema validate people/ada-lovelace.md

# Strict mode (treat warnings as errors)
bm schema validate person --strict

# Target a specific project
bm schema validate person --project research

# Route to local or cloud
bm schema validate person --local
bm schema validate person --cloud
```

| Flag | Description |
|------|-------------|
| `--strict` | Treat validation warnings as errors |
| `--project` | Target a specific project |
| `--local` | Force local routing |
| `--cloud` | Force cloud routing |

### `bm schema infer`

Infer a schema from existing notes.

```bash
# Infer schema for a note type
bm schema infer person

# Lower the threshold to include less common fields
bm schema infer person --threshold 0.1

# Save the inferred schema as a schema note
bm schema infer person --save

# Target a specific project
bm schema infer person --project research
```

| Flag | Description |
|------|-------------|
| `--threshold` | Minimum field frequency for inclusion (default `0.25`) |
| `--save` | Save the inferred schema as a schema note |
| `--project` | Target a specific project |
| `--local` | Force local routing |
| `--cloud` | Force cloud routing |

### `bm schema diff`

Detect drift between schema and actual usage.

```bash
# Check drift for a note type
bm schema diff person

# Target a specific project
bm schema diff person --project research
```

| Flag | Description |
|------|-------------|
| `--project` | Target a specific project |
| `--local` | Force local routing |
| `--cloud` | Force cloud routing |

---

## Complete example

Here's a full workflow for adding schemas to an existing knowledge base.

**Schema note** (`schemas/person.md`):

```yaml
---
title: Person
type: schema
entity: person
version: 1
schema:
  name: string, full name
  role?: string, job title
  email?: string, contact email
  works_at?: Organization, employer
  expertise?(array): string, areas of knowledge
settings:
  validation: warn
---
```

**A conforming person note** (`people/ada-lovelace.md`):

```yaml
---
title: Ada Lovelace
type: person
---

# Ada Lovelace

## Observations
- [name] Ada Lovelace
- [role] Mathematician and Writer
- [expertise] Mathematics
- [expertise] Computing theory

## Relations
- works_at [[Analytical Engine Project]]
```

**Validation:**

```bash
$ bm schema validate people/ada-lovelace.md
✓ ada-lovelace: valid (0 warnings)
```

If `[name]` were missing:

```bash
$ bm schema validate people/ada-lovelace.md
⚠ ada-lovelace: missing required field: name
```

---

## Common issues

**`No schema found`** — Create a schema note with `type: schema` for that note type, add an inline schema, or use an explicit `schema:` reference in frontmatter.

**`Missing required field`** — Add the observation or relation expected by the schema. For example, if `name: string` is required, add `- [name] Ada Lovelace` to the note.

**`Too many warnings`** — Either relax the schema by making more fields optional (`?`), or lower the inference threshold and regenerate with `bm schema infer person --threshold 0.1`.

---

## Best practices

- **Use specific note types** — Choose clear type values like `person`, `meeting`, `decision` rather than leaving everything as `note`.
- **Infer first, then refine** — Let Basic Memory analyze your existing patterns before writing schemas by hand.
- **Keep schema notes together** — Use a `schemas/` folder for easy discovery.
- **Run diff periodically** — Check for drift every few weeks to keep schemas aligned with how you actually write notes.
- **Adopt gradually** — Start with `warn` mode. Move to `strict` only after patterns stabilize.
- **Version your schemas** — Use the `version` field to track schema evolution over time.

---

## Next steps

:::card-group
::card
---
title: MCP Tools Reference
icon: i-lucide-wrench
to: /reference/mcp-tools-reference
---
Schema tool parameters and examples.
::

::card
---
title: CLI Reference
icon: i-lucide-terminal
to: /reference/cli-reference
---
Full `bm schema` command reference.
::

::card
---
title: AI Assistant Guide
icon: i-lucide-bot
to: /reference/ai-assistant-guide
---
How assistants can use schema tools in workflows.
::
:::
